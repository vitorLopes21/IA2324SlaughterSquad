package com.slaughtersquad.sampleRobots;

import com.slaughtersquad.utils.Utils;
import hex.genmodel.MojoModel;
import hex.genmodel.easy.EasyPredictModelWrapper;
import hex.genmodel.easy.RowData;
import hex.genmodel.easy.prediction.BinomialModelPrediction;
import hex.genmodel.easy.prediction.MultinomialModelPrediction;
import robocode.AdvancedRobot;
import robocode.RobotDeathEvent;
import robocode.RoundEndedEvent;
import robocode.ScannedRobotEvent;

import java.awt.*;
import java.awt.geom.Point2D;
import java.io.File;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Random;
import java.util.Collections;
import java.util.List;
import java.util.ArrayList;

/**
 * This Robot uses the model provided to guess whether it will hit or miss an enemy.
 * This is a very basic model, trained specifically on the following enemies: Corners, Crazy, SittingDuck, Walls.
 * It is not expected to do great...
 */
public class SlaughterSquad extends AdvancedRobot {
    private EnemyBot enemy;
    private EasyPredictModelWrapper model;
    private HashMap<String, Point2D.Double> enemies;
    private byte scanDirection = 2;

    /**
     * Calculate the velocity based on the distance to the destination
     * @param distanceToDestination The distance to the destination
     * @return The velocity to use
     */
    private double calculateVelocityBasedOnDistance(
            double distanceToDestination
    ) {
        if (distanceToDestination > 50) {
            return 45; // Large velocity for long distances
        } else {
            return 23; // Small velocity size for short distances
        }
    }

    /**
     * Turn the robot to a specific angle
     * @param targetAngle The angle to turn to
     */
    private void turnTo(double targetAngle) {
        double currentHeading = getHeading();
        double turnAngle = robocode.util.Utils.normalRelativeAngleDegrees(
                targetAngle - currentHeading
        );
        setTurnRight(turnAngle);
        execute();
    }

    /**
     * Follow the path generated by the genetic algorithm
     * @param bestPath The best path generated by the genetic algorithm
     * @param totalDistance The total distance to the destination
     */
    private void followPath(char[] bestPath, double totalDistance) {
        for (char move : bestPath) {
            switch (move) {
                case 'N' -> turnTo(0);
                case 'E' -> turnTo(90);
                case 'S' -> turnTo(180);
                case 'W' -> turnTo(270);
            }

            setAhead(calculateVelocityBasedOnDistance(totalDistance));
        }
    }

    /**
     * Solution Class
     *
     */
    private class Solution implements Comparable<Solution> {
        private Random random;
        private double fitness;
        private char[] path;

        public Solution(double fitness, char[] path) {
            this.random = new Random();
            this.path = path;
            this.fitness = fitness;
        }

        public Solution(Solution solution) {
            this.random = new Random();
            this.path = solution.getPath();
            this.fitness = solution.getFitness();
        }

        /**
         * Getter for the solution's fitness
         */
        public double getFitness() {
            return this.fitness;
        }

        /**
         * Getter for the solution's path
         * @return The path
         */
        public char[] getPath() {
            return Arrays.copyOf(this.path, this.path.length);
        }

        /**
         * Getter for the solution's path as a string
         * @return The path as a string
         */
        public String getPathString() {
            StringBuilder sb = new StringBuilder();

            for (char c : this.path) {
                sb.append(c);
            }

            return sb.toString();
        }

        /**
         * Function to apply mutation to 1 solution
         */
        protected void mutate() {
            int point = random.nextInt(this.path.length); // Random index to mutate
            this.path[point] = Population.MOVEMENTS[random.nextInt(Population.MOVEMENTS.length)]; // Mutate at the random index
        }

        /**
         * Function to apply crossover to 1 solution
         *
         * @param mother The mother solution, used to crossover with the father solution
         *               (this solution)
         * @return An array containing the 2 new solutions created by the crossover
         */
        protected Solution[] crossover(Solution mother) {
            int point = random.nextInt(mother.getPath().length); // Random crossover point

            char[] tempPath = Arrays.copyOf(this.path, this.path.length); // Copy of father's path
            System.arraycopy(mother.getPath(), 0, tempPath, point, mother.getPath().length - point); // Perform crossover

            char[] motherPath = Arrays.copyOf(mother.getPath(), mother.getPath().length); // Copy of mother's path
            System.arraycopy(this.path, 0, motherPath, point, this.path.length - point); // Perform crossover

            Solution[] children = new Solution[]{new Solution(this.fitness, tempPath), new Solution(mother.getFitness(), motherPath)}; // Return the children

            return children;
        }

        /**
         * Function to compare two solutions
         *
         * @param o The solution to compare to
         * @return -1 if this solution has a lower fitness, 1 if this solution has a
         *         higher fitness, 0 if they are equal
         */
        @Override
        public int compareTo(Solution o) {
            if (this.fitness < o.fitness) {
                return 1;
            } else if (this.fitness > o.fitness) {
                return -1;
            }
            return 0;
        }

        /**
         * Function to return the solution as a string
         */
        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();

            for (char c : this.path) {
                sb.append(c);
            }

            return sb.toString();
        }
    }

    /**
     * Population Class
     */
    private class Population {
        public static final char[] MOVEMENTS = { 'N', 'S', 'E', 'W' };
        public static final int POPULATION_SIZE = 200;
        public static final int POPUPLATION_HEREDITARY = 50;
        public static final int GENERATIONS = 10;
        public static final double MUTATION_RATE = 0.05;
        public static final double CROSSOVER_RATE = 0.2;
        public static int PATH_LENGTH;

        private HashMap<String, Point2D.Double> enemies;
        private Point2D.Double start;
        private Point2D.Double end;
        private double totalDistance;

        private ArrayList<Solution> solutions;

        private Random random;

        public Population(
                Point2D.Double start,
                Point2D.Double end,
                double distance,
                HashMap<String, Point2D.Double> enemies
        ) {
            this.random = new Random();
            this.start = start;
            this.end = end;
            this.totalDistance = distance;
            this.enemies = enemies;

            this.solutions = new ArrayList<>();
            Population.PATH_LENGTH = calculatePathLength(distance);

            for (int i = 0; i < POPULATION_SIZE; i++) {
                char[] path = new char[PATH_LENGTH];

                for (int j = 0; j < PATH_LENGTH; j++) {
                    path[j] = MOVEMENTS[random.nextInt(MOVEMENTS.length)];
                }

                this.solutions.add(
                        new Solution(this.fitnessFunction(path, start, end, enemies), path)
                );
            }
        }

        /**
         * Calculate the path length based on the distance to the destination
         * @param distance The distance to the destination
         * @return The path length
         */
        private int calculatePathLength(double distance) {
            return (int) Math.ceil(distance / 42);
        }

        /**
         * Fitness function to evaluate the path
         * @param path The path to evaluate
         * @param start The starting point
         * @param end The ending point
         * @param enemies The enemies on the battlefield
         * @return The fitness of the path
         */
        private double fitnessFunction(
                char[] path,
                Point2D.Double start,
                Point2D.Double end,
                HashMap<String, Point2D.Double> enemies
        ) {
            double x = start.x;
            double y = start.y;
            double battlefieldWidth = getBattleFieldWidth();
            double battlefieldHeight = getBattleFieldHeight();

            double distance = 0;
            double previousDistanceToEnd = start.distance(end);

            for (char move : path) {
                switch (move) {
                    case 'N' -> y += 1;
                    case 'S' -> y -= 1;
                    case 'E' -> x += 1;
                    case 'W' -> x -= 1;
                }

                // Check if the position hits an enemy
                if (enemies.containsValue(new Point2D.Double(x, y))) {
                    return Integer.MAX_VALUE; // Penalize movements that collide with enemies
                }

                // Penalty for hitting walls
                if (x < 0 || x > battlefieldWidth || y < 0 || y > battlefieldHeight) {
                    return Integer.MAX_VALUE; // Penalize movements that hit the walls
                }

                // Penalty for moving away from the end point
                double currentDistanceToEnd = new Point2D.Double(x, y).distance(end);
                if (currentDistanceToEnd > previousDistanceToEnd) {
                    distance += 10; // Penalize moving away from the end point
                }
                previousDistanceToEnd = currentDistanceToEnd;

                distance += 1; // Basic distance increment
            }

            distance += Math.abs(x - end.x) + Math.abs(y - end.y);
            return distance;
        }

        /**
         * Function to iterate over the population
         * @return The best path found
         */
        public char[] iterate() {
            for (int i = 0; i < GENERATIONS; i++) {
                List<Solution> currentSolutions = this.solutions;

                currentSolutions.sort(Collections.reverseOrder());

                // Get POPUPLATION_HEREDITARY number of best solutions
                ArrayList<Solution> nextGen = new ArrayList<>();

                for (int j = 0; j < POPUPLATION_HEREDITARY; j++) {
                    nextGen.add(currentSolutions.get(j));
                }

                // From the best POPUPLATION_HEREDITARY solutions, mutate POPUPLATION_HEREDITARY
                // * MUTATION_RATE solutions
                // to them before adding everything to the next generation
                for (int j = 0; j < POPUPLATION_HEREDITARY * MUTATION_RATE; j++) {
                    Solution solution = new Solution(nextGen.get(j));

                    solution.mutate();
                    nextGen.add(solution);
                }

                // From the best POPUPLATION_HEREDITARY solutions, crossover
                // POPUPLATION_HEREDITARY * CROSSOVER_RATE solutions
                // to them before adding everything to the next generation
                for (int j = 0; j < POPUPLATION_HEREDITARY * CROSSOVER_RATE; j++) {
                    Solution father = new Solution(nextGen.get(j));
                    Solution mother = new Solution(nextGen.get(j + 1));

                    Solution[] children = father.crossover(mother);

                    nextGen.add(children[0]);
                    nextGen.add(children[1]);
                }

                this.solutions = nextGen;

                this.solutions.sort(Collections.reverseOrder());
            }

            return this.solutions.get(0).getPath();
        }
    }

    /**
     * Run the robot
     */
    @Override
    public void run() {
        super.run();

        this.enemies = new HashMap<>();

        File dir = getDataDirectory(); // Use Robocode's method to get the data directory
        File[] files = dir.listFiles(); // List all files in the directory

        File modelFile = null;
        assert files != null;
        for (File file : files) {
            if (file.getName().endsWith(".zip")) {
                modelFile = file; // Found a matching file
                break;
            }
        }

        if (modelFile != null) {
            try {
                model = new EasyPredictModelWrapper(MojoModel.load(modelFile.getAbsolutePath()));
                System.out.println("Model loaded successfully");
            } catch (IOException e) {
                e.printStackTrace();
            }
        } else {
            System.out.println("No matching model file found");
        }

        // Allow the gun and radar to turn independently
        setAdjustRadarForRobotTurn(true);
        setAdjustGunForRobotTurn(true);

        enemy = new EnemyBot();

        while (true) {
            turnRadarRight(360 * scanDirection);
            setAllColors(new Color(3, 3, 3));
            execute();
        }
    }

    @Override
    public void onScannedRobot(ScannedRobotEvent event) {
        // track if we have no enemy, the one we found is significantly
        // closer, or we scanned the one we've been tracking.
        if (enemy.isReset() || event.getDistance() < enemy.getDistance() ||
                event.getName().equals(enemy.getName())) {

            // track him using the NEW update method
            enemy.update(event, this);

            if (!enemies.containsKey(event.getName())) {
                enemies.put(event.getName(), new Point2D.Double(enemy.getX(), enemy.getY()));
            }
        }

        if (enemy.getDistance() < 300) {
            scanDirection *= -1;
        }

        setTurnRadarRight(360 * scanDirection);

        // Pick a random spot on the battlefield to move towards
        Point2D.Double start = new Point2D.Double(getX(), getY());
        Point2D.Double end = new Point2D.Double(enemy.getX(), enemy.getY());
        Population population = new Population(start, end, start.distance(end), enemies);
        char[] bestPath = population.iterate();

        followPath(bestPath, start.distance(end));

        double firePower = Math.min(500 / enemy.getDistance(), 3);

        double bulletSpeed = 20 - firePower * 3;

        long time = (long) (event.getDistance() / bulletSpeed);

        double futureX = enemy.getFutureX(time);
        double futureY = enemy.getFutureY(time);

        double absDeg = Utils.absoluteBearing(getX(), getY(), futureX, futureY);
        double normalizedAbsDeg = Utils.normalizeBearing(absDeg - getGunHeading());

        setTurnGunRight(normalizedAbsDeg);

        RowData row = new RowData();
        row.put("currentPositionX", getX());
        row.put("currentPositionY", getY());
        row.put("distance", event.getDistance());
        row.put("velocity", event.getVelocity());
        row.put("bearing", event.getBearing());
        row.put("futureBearing", normalizedAbsDeg);
        row.put("predictedEnemyPositionX", futureX);
        row.put("predictedEnemyPositionY", futureY);

        try {
            if (model != null) {
                BinomialModelPrediction p = model.predictBinomial(row);
                System.out.println("Will I hit? ->" + p.label);

                if (p.label.equals("hit")) {
                    setFire(firePower);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Override
    public void onRobotDeath(RobotDeathEvent e) {
        if (e.getName().equals(enemy.getName())) {
            enemy.reset();
        }
    }

    @Override
    public void onRoundEnded(RoundEndedEvent event) {
        // Reset the enemy
        enemy.reset();
    }
}
